name: CI & Deploy ProcurementHTE (.dll + EF SQL script)

on:
  push:
    branches: [master]
  workflow_dispatch:

concurrency:
  group: deploy-master
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: master

      - name: Setup .NET 9
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "9.0.x"

      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
          restore-keys: nuget-${{ runner.os }}-

      - name: Restore
        run: dotnet restore

      - name: Build & Test
        run: |
          dotnet build -c Release --no-restore
          dotnet test -c Release --no-build --verbosity normal

      - name: Prepare EF CLI (local tool, pinned 9.*)
        shell: bash
        run: |
          set -e
          dotnet new tool-manifest --force
          for i in 1 2 3; do
            if dotnet tool install dotnet-ef --version 9.*; then
              break
            fi
            echo "[WARN] dotnet-ef install failed (attempt $i). Clearing NuGet caches and retrying..."
            dotnet nuget locals all --clear
            rm -rf ~/.nuget/packages/dotnet-ef || true
            sleep 2
          done
          dotnet tool list

      - name: Publish + generate Migrations.sql (idempotent)
        shell: bash
        env:
          EF_CONNECTION: ${{ secrets.DB_CONNECTION }} # jika DesignTimeDbContextFactory perlu
        run: |
          set -e
          dotnet publish ProcurementHTE.Web/ProcurementHTE.Web.csproj -c Release -o out
          dotnet build ProcurementHTE.Infrastructure/ProcurementHTE.Infrastructure.csproj -c Release --no-restore
          dotnet tool run dotnet-ef migrations script \
            --project ProcurementHTE.Infrastructure \
            --startup-project ProcurementHTE.Infrastructure \
            --configuration Release \
            --framework net9.0 \
            --idempotent \
            --output out/Migrations.sql
            
          ls -la out

      - name: Install Playwright browsers (pack into artifact)
        shell: pwsh
        working-directory: out
        env:
          PLAYWRIGHT_BROWSERS_PATH: ./.playwright
        run: |
          Write-Host "Listing publish output before Playwright install"
          Get-ChildItem -Force
          ./playwright.ps1 install --with-deps
          if (-not (Test-Path ".playwright")) {
            Write-Error "Playwright runtime missing in publish output"
          }
          Write-Host "Listing .playwright after install"
          Get-ChildItem -Recurse -Force ".playwright"

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: app
          path: out/

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment: production
    env:
      DEPLOY_DIR: ${{ vars.DEPLOY_DIR }} # contoh: /var/www/ProcurementHTE
      APP_SERVICE: ${{ vars.APP_SERVICE }} # contoh: procurementhte.service
      DB_USER: ${{ secrets.DB_USER }} # contoh: sa
      DB_PASS: ${{ secrets.DB_PASS }}
      DB_NAME: ${{ vars.DB_NAME }} # kalau kosong, di-script kita kasih default
      DB_PORT: ${{ vars.DB_PORT }} # kalau kosong, di-script kita kasih default 1433
      MSSQL_CONTAINER: ${{ vars.MSSQL_CONTAINER }} # nama container SQL (set di repo/env vars)
    steps:
      - name: Check SSH port reachable
        run: nc -vz -w 10 ${{ secrets.SSH_HOST }} ${{ secrets.SSH_PORT }}

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: app
          path: artifact

      - name: Compute release name (runNumber-sha7)
        shell: bash
        run: |
          SHORT_SHA=${GITHUB_SHA::7}
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
          echo "RELEASE_NAME=${GITHUB_RUN_NUMBER}-${SHORT_SHA}" >> $GITHUB_ENV
          echo "RDIR=/releases/${GITHUB_RUN_NUMBER}-${SHORT_SHA}" >> $GITHUB_ENV
          echo "Done: $RELEASE_NAME"

      - name: Prepare /var/www permissions (safe + auto-detect sudo)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          envs: DEPLOY_DIR
          script: |
            set -Eeuo pipefail
            : "${DEPLOY_DIR:?DEPLOY_DIR is empty}"

            echo "[INFO] Preparing DEPLOY_DIR=$DEPLOY_DIR"

            # Ensure base directory exists (no root required)
            install -d -m 755 "$DEPLOY_DIR" || mkdir -p "$DEPLOY_DIR"

            # Try making sure permissions work
            if sudo -n true 2>/dev/null; then
              echo "[INFO] sudo detected - fixing ownership"
              sudo mkdir -p "$DEPLOY_DIR"
              sudo chown -R "$(whoami):$(whoami)" "$DEPLOY_DIR"
            else
              echo "[WARN] sudo NOT available - using default ownership"
            fi

            echo "[INFO] After prepare:"
            ls -ld "$DEPLOY_DIR"

      - name: Create release dir on server
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          envs: DEPLOY_DIR,RELEASE_NAME
          script_stop: true
          script: |
            set -Eeuo pipefail
            : "${DEPLOY_DIR:?DEPLOY_DIR is empty or not set}"
            : "${RELEASE_NAME:?RELEASE_NAME is empty or not set}"

            echo "[INFO] DEPLOY_DIR=$DEPLOY_DIR, RELEASE_NAME=$RELEASE_NAME"
            # Create directories as the SSH user (avoid install -o/-g which requires root)
            install -d -m 755 "$DEPLOY_DIR" || mkdir -p "$DEPLOY_DIR"
            install -d -m 755 "$DEPLOY_DIR/releases" || mkdir -p "$DEPLOY_DIR/releases"
            install -d -m 755 "$DEPLOY_DIR/publish" || mkdir -p "$DEPLOY_DIR/publish"

            RELEASE="$DEPLOY_DIR/releases/$RELEASE_NAME"
            install -d -m 755 "$RELEASE" || mkdir -p "$RELEASE"

            # App expects Templates/Documents to exist at runtime; create it here to avoid permission issues
            install -d -m 755 "$RELEASE/Templates/Documents" || mkdir -p "$RELEASE/Templates/Documents"

            # Write release path for downstream steps
            echo "$RELEASE" > "$DEPLOY_DIR/.release_path"
            echo "[INFO] Release path: $RELEASE"

            # If the SSH user can sudo without a password, set ownership to the SSH user (optional)
            if sudo -n true 2>/dev/null; then
              sudo chown -R "$(whoami):$(whoami)" "$DEPLOY_DIR" || true
            fi

      - name: Upload release files (DLL + Migrations.sql)
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          source: "artifact/**"
          target: "${{ env.DEPLOY_DIR }}/releases/${{ env.RELEASE_NAME }}"
          strip_components: 1
          overwrite: true

      - name: Sync Playwright runtime to app root
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          debug: true
          envs: DEPLOY_DIR,RELEASE_NAME
          script_stop: true
          script: |
            set -Eeuo pipefail
            SRC="$DEPLOY_DIR/releases/$RELEASE_NAME/.playwright"
            DST="$DEPLOY_DIR/.playwright"
            echo "[INFO] ls release dir:"
            ls -la "$DEPLOY_DIR/releases/$RELEASE_NAME" || true
            if [ ! -d "$SRC" ]; then
              echo "[ERR] .playwright not found in release; aborting"
              exit 1
            fi
            mkdir -p "$DST"
            cp -a "$SRC/." "$DST/"
            echo "[OK] Playwright runtime synced to $DST"

      - name: Verify release contents
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          envs: DEPLOY_DIR,RELEASE_NAME
          # (no script_stop here; biar warning Migrations.sql tidak blokir)
          script: |
            set -Eeuo pipefail
            RELEASE="$DEPLOY_DIR/releases/$RELEASE_NAME"
            echo "[INFO] ls -la $RELEASE"
            ls -la "$RELEASE"
            test -f "$RELEASE/ProcurementHTE.Web.dll" || { echo "[ERR] DLL not found in $RELEASE"; exit 1; }
            test -f "$RELEASE/Migrations.sql" || echo "[WARN] Migrations.sql not found (no DB changes?)"
            echo "[OK] Found DLL & (maybe) Migrations.sql"

      - name: Apply DB migrations (Docker-only)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          debug: true
          envs: DEPLOY_DIR,RELEASE_NAME,DB_USER,DB_PASS,DB_NAME,DB_PORT,MSSQL_CONTAINER
          script_stop: true
          script: |
            set -Eeuo pipefail
            set -x

            echo "[INFO] MSSQL_CONTAINER='${MSSQL_CONTAINER:-<not set>}' DB_NAME='${DB_NAME:-ProcurementHTE}' DB_PORT='${DB_PORT:-1433}'"

            # default kalau env kosong
            : "${DB_NAME:=ProcurementHTE}"
            : "${DB_PORT:=1433}"

            RELEASE="$DEPLOY_DIR/releases/$RELEASE_NAME"
            MIG="$RELEASE/Migrations.sql"
            [ -s "$MIG" ] || { echo "[INFO] No migrations to apply (file missing or empty)"; exit 0; }

            DOCKER="docker"
            if ! $DOCKER info >/dev/null 2>&1; then
              if command -v sudo >/dev/null 2>&1 && sudo -n docker info >/dev/null 2>&1; then
                DOCKER="sudo docker"
              else
                echo "[ERR] Docker not accessible"; exit 1
              fi
            fi

            # ============================================================
            #  DETERMINISTIC CONTAINER SELECTION (CANNOT RETURN MULTILINE)
            # ============================================================
            get_single_container() {
              # 1) Jika MSSQL_CONTAINER ditentukan -> cari by name (no strict anchor)
              if [ -n "${MSSQL_CONTAINER:-}" ]; then
                local by_name
                by_name="$($DOCKER ps -q -f name="$MSSQL_CONTAINER" | tr -s '\n' ' ')"
                if [ -n "$by_name" ]; then
                  echo "$by_name" | awk '{print $1}'
                  return 0
                fi
                echo "[WARN] MSSQL_CONTAINER='$MSSQL_CONTAINER' not found by name. Available containers:"
                $DOCKER ps --format "table {{.ID}}\t{{.Names}}\t{{.Image}}"
              fi

              # 2) Cari SQL container berdasarkan image
              local sql_list
              sql_list="$($DOCKER ps -q -f ancestor=mcr.microsoft.com/mssql/server | tr -s '\n' ' ')"

              if [ -z "$sql_list" ]; then
                echo "[ERR] No SQL Server container running. Current containers:"
                $DOCKER ps --format "table {{.ID}}\t{{.Names}}\t{{.Image}}"
                return 1
              fi

              # 3) Validasi hanya satu
              local count
              count=$(echo "$sql_list" | wc -w)

              if [ "$count" -gt 1 ]; then
                echo "[ERR] Multiple SQL containers detected:"
                $DOCKER ps --format "table {{.ID}}\t{{.Names}}\t{{.Image}}"
                echo "[HINT] Set MSSQL_CONTAINER in GitHub secrets."
                return 1
              fi

              echo "$sql_list"
            }

            CID="$(get_single_container)" || exit 1
            echo "[INFO] SQL container selected: $CID"

            # ============================================================
            #  FIND SQLCMD INSIDE CONTAINER (GUARANTEED SINGLE-LINE)
            # ============================================================
            BIN="$(
              $DOCKER exec "$CID" bash -lc '
                for b in /opt/mssql-tools18/bin/sqlcmd /opt/mssql-tools/bin/sqlcmd sqlcmd; do
                  if command -v "$b" >/dev/null 2>&1; then echo "$b"; exit 0; fi
                done; exit 1
              '
            )"

            # Pastikan DB ada (create jika hilang)
            $DOCKER exec -e DB_USER -e DB_PASS -e DB_NAME "$CID" bash -lc "
              $BIN -S localhost,${DB_PORT} -U \"\$DB_USER\" -P \"\$DB_PASS\" -C \
                -Q \"IF DB_ID('${DB_NAME}') IS NULL CREATE DATABASE [${DB_NAME}];\"
            "

            # ============================================================
            #  CHECK DATABASE STATE
            # ============================================================
            HAS_HIST="$(
              $DOCKER exec -e DB_USER -e DB_PASS -e DB_NAME "$CID" bash -lc "
                $BIN -S localhost,${DB_PORT} -U \"\$DB_USER\" -P \"\$DB_PASS\" -d \"\$DB_NAME\" -C -h -1 -W \
                  -Q \"SET NOCOUNT ON; SELECT CASE WHEN OBJECT_ID('__EFMigrationsHistory') IS NULL THEN 0 ELSE 1 END\" \
                  | tr -d '\r'
              "
            )"

            TABLES_COUNT="$(
              $DOCKER exec -e DB_USER -e DB_PASS -e DB_NAME "$CID" bash -lc "
                $BIN -S localhost,${DB_PORT} -U \"\$DB_USER\" -P \"\$DB_PASS\" -d \"\$DB_NAME\" -C -h -1 -W \
                  -Q \"SET NOCOUNT ON; SELECT COUNT(*) FROM sys.tables\" \
                  | tr -d '\r'
              "
            )"

            echo "[INFO] HasHistory=${HAS_HIST:-?}, Tables=${TABLES_COUNT:-?}"

            # Stop kalau DB sudah berisi tabel tapi __EFMigrationsHistory belum ada
            if [ "${HAS_HIST:-0}" = "0" ] && [ "${TABLES_COUNT:-0}" -gt 0 ]; then
              echo "[ERR] __EFMigrationsHistory missing but tables exist. Do manual baseline then rerun."
              exit 1
            fi

            # ============================================================
            #  APPLY MIGRATIONS
            # ============================================================
            echo "[INFO] Apply Migrations.sql..."
            $DOCKER cp "$MIG" "$CID:/tmp/mig.sql"
            $DOCKER exec -e DB_USER -e DB_PASS -e DB_NAME "$CID" bash -lc "
              $BIN -I -S localhost,${DB_PORT} -U \"\$DB_USER\" -P \"\$DB_PASS\" -d \"\$DB_NAME\" -C -b -V16 -i /tmp/mig.sql
            "
            echo "[OK] DB migrations applied."

      - name: Activate & restart service
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          envs: DEPLOY_DIR,APP_SERVICE,RELEASE_NAME
          script_stop: true
          script: |
            set -Eeuo pipefail
            : "${DEPLOY_DIR:?DEPLOY_DIR is empty or not set}"
            : "${APP_SERVICE:?APP_SERVICE is empty or not set}"
            : "${RELEASE_NAME:?RELEASE_NAME is empty or not set}"
            RELEASE="$DEPLOY_DIR/releases/$RELEASE_NAME"
            test -f "$RELEASE/ProcurementHTE.Web.dll" || { echo "[ERR] Missing DLL in $RELEASE"; exit 1; }
            ln -sfn "$RELEASE" "$DEPLOY_DIR/publish/current"
            echo "[INFO] current -> $(readlink -f "$DEPLOY_DIR/publish/current")"
            sudo systemctl daemon-reload || true
            sudo systemctl restart "$APP_SERVICE"
            sudo systemctl --no-pager --full status "$APP_SERVICE" || true

      - name: Smoke check (wait until 5159 is ready)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: deploy
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          envs: APP_SERVICE
          script: |
            set -Eeuo pipefail

            echo "[INFO] waiting up to 60s for Kestrel :5159 ..."
            deadline=$((SECONDS+60))
            while [ $SECONDS -lt $deadline ]; do
              if ss -tln | awk '{print $4}' | grep -qE '(^|:)5159$'; then
                echo "[OK] 5159 is listening"
                curl -sS -I -m 5 -H 'Host: procurementhte.dev' -H 'X-Forwarded-Proto: https' http://127.0.0.1:5159/ | head -n1 || true
                exit 0
              fi
              sleep 1
            done

            echo "[ERR] 5159 not listening after 60s. Open dotnet ports:"
            ss -tlnp | grep -E '(:5159|dotnet)' || true

            echo "=== systemd status ==="
            sudo -n systemctl --no-pager --full status "$APP_SERVICE" || true
            echo "=== last 200 logs ==="
            sudo -n journalctl -u "$APP_SERVICE" -n 200 --no-pager || true
            exit 1
