name: CI & Deploy ProcurementHTE (.dll + EF SQL script)

on:
  push:
    branches: [master]
  workflow_dispatch:

concurrency:
  group: deploy-master
  cancel-in-progress: true

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: master

      - name: Setup .NET 9
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: "9.0.x"

      - name: Cache NuGet
        uses: actions/cache@v4
        with:
          path: ~/.nuget/packages
          key: nuget-${{ runner.os }}-${{ hashFiles('**/*.csproj') }}
          restore-keys: nuget-${{ runner.os }}-

      - name: Restore
        run: dotnet restore

      - name: Build & Test
        run: |
          dotnet build -c Release --no-restore
          dotnet test -c Release --no-build --verbosity normal

      - name: Prepare EF CLI (local tool, pinned 9.*)
        shell: bash
        run: |
          set -e
          dotnet new tool-manifest --force
          for i in 1 2 3; do
            if dotnet tool install dotnet-ef --version 9.*; then
              break
            fi
            echo "[WARN] dotnet-ef install failed (attempt $i). Clearing NuGet caches and retrying..."
            dotnet nuget locals all --clear
            rm -rf ~/.nuget/packages/dotnet-ef || true
            sleep 2
          done
          dotnet tool list

      - name: Publish + generate Migrations.sql (idempotent)
        env:
          EF_CONNECTION: ${{ secrets.DB_CONNECTION }} # jika DesignTimeDbContextFactory perlu
        run: |
          set -e
          dotnet publish ProcurementHTE.Web/ProcurementHTE.Web.csproj -c Release -o out
          dotnet build ProcurementHTE.Infrastructure/ProcurementHTE.Infrastructure.csproj -c Release --no-restore
          dotnet tool run dotnet-ef migrations script \
            --project ProcurementHTE.Infrastructure \
            --startup-project ProcurementHTE.Infrastructure \
            --configuration Release \
            --framework net9.0 \
            --idempotent \
            --output out/Migrations.sql
          
          ls -la out

      # NOTE:
      # Runtime Playwright untuk .NET sekarang di-install sekali di server (Pola B)
      # ke /var/www/ProcurementHTE/.playwright, bukan lewat npx di artifact.
      # Step lama `npx playwright install chromium --with-deps` dihapus.

      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: app
          path: out/

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment: production
    env:
      DEPLOY_DIR: ${{ vars.DEPLOY_DIR }} # contoh: /var/www/ProcurementHTE
      APP_SERVICE: ${{ vars.APP_SERVICE }} # contoh: procurementhte.service
      DB_USER: ${{ secrets.DB_USER }} # contoh: sa
      DB_PASS: ${{ secrets.DB_PASS }}
      DB_NAME: ${{ vars.DB_NAME }} # kalau kosong, di-script kita kasih default
      DB_PORT: ${{ vars.DB_PORT }} # kalau kosong, di-script kita kasih default 1433
      MSSQL_CONTAINER: ${{ vars.MSSQL_CONTAINER }} # nama container SQL (set di repo/env vars)
    steps:
      - name: Check SSH port reachable
        run: nc -vz -w 10 ${{ secrets.SSH_HOST }} ${{ secrets.SSH_PORT }}

      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: app
          path: artifact

      - name: Compute release name (runNumber-sha7)
        shell: bash
        run: |
          SHORT_SHA=${GITHUB_SHA::7}
          echo "SHORT_SHA=$SHORT_SHA" >> $GITHUB_ENV
          echo "RELEASE_NAME=${GITHUB_RUN_NUMBER}-${SHORT_SHA}" >> $GITHUB_ENV
          echo "RDIR=/releases/${GITHUB_RUN_NUMBER}-${SHORT_SHA}" >> $GITHUB_ENV
          echo "Done: $RELEASE_NAME"

      - name: Prepare /var/www permissions (safe + auto-detect sudo)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          envs: DEPLOY_DIR,RELEASE_NAME
          script: |
            set -Eeuo pipefail
            : "${DEPLOY_DIR:?DEPLOY_DIR is empty}"
            : "${RELEASE_NAME:?RELEASE_NAME is empty}"

            echo "[INFO] Preparing DEPLOY_DIR=$DEPLOY_DIR"

            # Ensure base directory exists (no root required)
            install -d -m 755 "$DEPLOY_DIR" || mkdir -p "$DEPLOY_DIR"

            # Try making sure permissions work
            if sudo -n true 2>/dev/null; then
              echo "[INFO] sudo detected - fixing ownership"
              sudo mkdir -p "$DEPLOY_DIR"
              sudo chown -R "$(whoami):$(whoami)" "$DEPLOY_DIR"
            else
              echo "[WARN] sudo NOT available - using default ownership"
            fi

            # Create directories as the SSH user (avoid install -o/-g which requires root)
            install -d -m 755 "$DEPLOY_DIR" || mkdir -p "$DEPLOY_DIR"
            install -d -m 755 "$DEPLOY_DIR/releases" || mkdir -p "$DEPLOY_DIR/releases"
            install -d -m 755 "$DEPLOY_DIR/publish" || mkdir -p "$DEPLOY_DIR/publish"

            RELEASE="$DEPLOY_DIR/releases/$RELEASE_NAME"
            install -d -m 755 "$RELEASE" || mkdir -p "$RELEASE"

            # App expects Templates/Documents to exist at runtime; create it here to avoid permission issues
            install -d -m 755 "$RELEASE/Templates/Documents" || mkdir -p "$RELEASE/Templates/Documents"

            # Write release path for downstream steps
            echo "$RELEASE" > "$DEPLOY_DIR/.release_path"
            echo "[INFO] Release path: $RELEASE"

      - name: Upload release to server (scp)
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          source: "artifact/**"
          target: "${{ env.DEPLOY_DIR }}/releases/${{ env.RELEASE_NAME }}"
          strip_components: 1
          overwrite: true

      - name: Verify release contents
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          envs: DEPLOY_DIR,RELEASE_NAME
          # (no script_stop here; biar warning Migrations.sql tidak blokir)
          script: |
            set -Eeuo pipefail
            RELEASE="$DEPLOY_DIR/releases/$RELEASE_NAME"
            echo "[INFO] ls -la $RELEASE"
            ls -la "$RELEASE"
            test -f "$RELEASE/ProcurementHTE.Web.dll" || { echo "[ERR] DLL not found in $RELEASE"; exit 1; }
            test -f "$RELEASE/Migrations.sql" || echo "[WARN] Migrations.sql not found (no DB changes?)"
            echo "[OK] Found DLL & (maybe) Migrations.sql"

      - name: Apply DB migrations (Docker-only)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          envs: DEPLOY_DIR,RELEASE_NAME,DB_USER,DB_PASS,DB_NAME,DB_PORT,MSSQL_CONTAINER
          script_stop: true
          script: |
            set -Eeuo pipefail
            trap 'echo "[ERR] Failed at line $LINENO: $BASH_COMMAND"' ERR
            set -x  # debug until sqlcmd execution (disabled before credentials)

            echo "[STEP] start-migrate"
            echo "[INFO] host=$(hostname) pwd=$(pwd)"
            uname -a || true
            whoami || true

            # Default DB_NAME/DB_PORT kalau kosong
            DB_NAME="${DB_NAME:-ProcurementHTE}"
            DB_PORT="${DB_PORT:-1433}"

            if [ -z "${DB_USER:-}" ] || [ -z "${DB_PASS:-}" ]; then
              echo "[ERR] DB_USER/DB_PASS missing"
              exit 1
            fi

            echo "[INFO] Using DB: $DB_NAME (port $DB_PORT) as $DB_USER on MSSQL_CONTAINER=$MSSQL_CONTAINER"

            # Pastikan Docker ada
            if ! command -v docker >/dev/null 2>&1; then
              if command -v sudo >/dev/null 2>&1; then
                echo "[INFO] docker not in PATH, trying with sudo docker"
                DOCKER="sudo docker"
              else
                echo "[ERR] Docker not installed"; exit 1
              fi
            else
              DOCKER="docker"
            fi

            echo "[STEP] docker-command=$DOCKER"
            # Coba cek akses docker tanpa password
            if ! $DOCKER ps; then
              if command -v sudo >/dev/null 2>&1; then
                echo "[INFO] docker ps failed, trying sudo docker ps"
                DOCKER="sudo docker"
              else
                echo "[ERR] Docker not accessible"; exit 1
              fi
            fi

            echo "[INFO] docker ps -a (debug)"
            $DOCKER ps -a
            echo "[STEP] docker-ps-done"

            # ============================================================
            #  DETERMINISTIC CONTAINER SELECTION (CANNOT RETURN MULTILINE)
            # ============================================================
            get_single_container() {
              # 1) Jika MSSQL_CONTAINER ditentukan -> cari by name (no strict anchor)
              if [ -n "${MSSQL_CONTAINER:-}" ]; then
                local by_name
                by_name="$($DOCKER ps -q -f name="$MSSQL_CONTAINER" | tr -s '\n' ' ')"
                echo "[INFO] Candidate containers by name '$MSSQL_CONTAINER': $by_name"
                if [ -n "$by_name" ]; then
                  set -- $by_name
                  echo "$1"
                  return 0
                fi
              fi

              # 2) Fallback: cari container yang expose port 1433
              local by_port
              by_port="$($DOCKER ps -q -f publish=1433 | tr -s '\n' ' ')"
              if [ -z "$by_port" ]; then
                echo "[ERR] No SQL Server container found (MSSQL_CONTAINER empty and no port 1433 exposed)" >&2
                return 1
              fi

              # Ambil container pertama
              set -- $by_port
              echo "$1"
              return 0
            }

            CONTAINER_ID="$(get_single_container)" || exit 1
            echo "[INFO] Using SQL container: $CONTAINER_ID"

            RELEASE_PATH="$DEPLOY_DIR/releases/$RELEASE_NAME/Migrations.sql"
            echo "[INFO] RELEASE_PATH=$RELEASE_PATH"
            ls -la "$(dirname "$RELEASE_PATH")" || true
            if [ ! -f "$RELEASE_PATH" ]; then
              echo "[WARN] No Migrations.sql found, skipping DB migrations."
              exit 0
            fi

            echo "[STEP] release-path-ok"
            echo "[INFO] Copy Migrations.sql into container..."
            $DOCKER cp "$RELEASE_PATH" "$CONTAINER_ID:/tmp/Migrations.sql"
            echo "[STEP] cp-done"

            # Detect sqlcmd path inside the container
            SQLCMD_BIN=""
            for candidate in /opt/mssql-tools18/bin/sqlcmd /opt/mssql-tools/bin/sqlcmd sqlcmd; do
              if $DOCKER exec "$CONTAINER_ID" test -x "$candidate" 2>/dev/null; then
                SQLCMD_BIN="$candidate"
                break
              fi
            done
            if [ -z "$SQLCMD_BIN" ]; then
              echo "[ERR] sqlcmd not found inside container $CONTAINER_ID"
              exit 1
            fi

            echo "[STEP] sqlcmd-found=$SQLCMD_BIN"
            echo "[INFO] Preview Migrations.sql (first 30 lines)"
            head -n 30 "$RELEASE_PATH" || true

            echo "[INFO] Running migrations inside container using $SQLCMD_BIN..."
            set +x  # avoid leaking credentials
            if ! $DOCKER exec "$CONTAINER_ID" "$SQLCMD_BIN" \
              -S "127.0.0.1,$DB_PORT" \
              -U "$DB_USER" \
              -P "$DB_PASS" \
              -d "$DB_NAME" \
              -l 30 \
              -b \
              -i "/tmp/Migrations.sql"
            then
              set +x
              echo "[ERR] sqlcmd failed. Showing last 50 container logs for context:"
              $DOCKER logs "$CONTAINER_ID" | tail -n 50 || true
              exit 1
            fi
            set +x

            echo "[OK] Migrations applied successfully."

      - name: Switch current release & restart service
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          envs: DEPLOY_DIR,RELEASE_NAME,APP_SERVICE
          script: |
            set -Eeuo pipefail
            : "${DEPLOY_DIR:?DEPLOY_DIR is empty}"
            : "${APP_SERVICE:?APP_SERVICE is empty}"

            RELEASE="$DEPLOY_DIR/releases/$RELEASE_NAME"
            test -f "$RELEASE/ProcurementHTE.Web.dll" || { echo "[ERR] DLL not found in $RELEASE"; exit 1; }

            # Update .release_path
            echo "$RELEASE" > "$DEPLOY_DIR/.release_path"
            echo "[INFO] Now pointing .release_path to $RELEASE"

            # Restart systemd service
            if command -v sudo >/dev/null 2>&1; then
              echo "[INFO] Restarting systemd service $APP_SERVICE via sudo..."
              sudo systemctl daemon-reload || true
              sudo systemctl restart "$APP_SERVICE"
            else
              echo "[ERR] sudo not available; cannot restart systemd service $APP_SERVICE"
              exit 1
            fi

      - name: Verify app responds on 5159 (with Host header)
        uses: appleboy/ssh-action@v1.2.0
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          passphrase: ${{ secrets.SSH_PASSPHRASE }}
          port: ${{ secrets.SSH_PORT }}
          envs: APP_SERVICE
          script: |
            set -Eeuo pipefail

            echo "[INFO] Checking app health on http://127.0.0.1:5159/"
            for i in $(seq 1 60); do
              if curl -sS -m 5 -H 'Host: procurementhte.dev' -H 'X-Forwarded-Proto: https' http://127.0.0.1:5159/ | head -n1 >/dev/null 2>&1; then
                echo "[OK] App responded on attempt $i"
                exit 0
              fi
              echo "[WARN] Attempt $i: app not responding yet, retrying..."
              sleep 1
            done

            echo "[ERR] 5159 not listening after 60s. Open dotnet ports:"
            ss -tlnp | grep -E '(:5159|dotnet)' || true

            echo "=== systemd status ==="
            sudo -n systemctl --no-pager --full status "$APP_SERVICE" || true
            echo "=== last 200 logs ==="
            sudo -n journalctl -u "$APP_SERVICE" -n 200 --no-pager || true
            exit 1
